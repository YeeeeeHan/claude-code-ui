diff --git a/dist/index.d.ts b/dist/index.d.ts
index ad98e45ccdabc447f2dc70789c1c0c2d881a8eca..1eeb2abfb78bb73c2707a0420d8299b741c83fb8 100644
--- a/dist/index.d.ts
+++ b/dist/index.d.ts
@@ -1,5 +1,5 @@
 import { Collection, createOptimisticAction } from "@tanstack/db";
-import { DurableStream, DurableStreamOptions } from "@durable-streams/client";
+import { DurableStream, DurableStreamOptions, LiveMode, SSEResilienceOptions } from "@durable-streams/client";
 import { StandardSchemaV1 } from "@standard-schema/spec";
 
 //#region src/types.d.ts
@@ -183,11 +183,33 @@ type ActionFactory<TDef extends StreamStateDefinition, TActions extends Record<s
 */
 type ActionMap<TActions extends Record<string, ActionDefinition<any>>> = { [K in keyof TActions]: ReturnType<typeof createOptimisticAction<any>> };
 /**
+* Extended stream options with live mode support
+*/
+interface ExtendedStreamOptions extends DurableStreamOptions {
+  /**
+  * Live mode behavior:
+  * - false: Catch-up only, stop at first `upToDate`
+  * - "auto" (default): Behavior driven by consumption method
+  * - "long-poll": Explicit long-poll mode for live updates
+  * - "sse": Explicit server-sent events for live updates
+  */
+  live?: LiveMode;
+  /**
+  * Hint: treat content as JSON even if Content-Type doesn't say so.
+  * Required when using SSE mode (text/event-stream) with JSON data.
+  */
+  json?: boolean;
+  /**
+  * SSE resilience options for fallback behavior
+  */
+  sseResilience?: SSEResilienceOptions;
+}
+/**
 * Options for creating a stream DB
 */
 interface CreateStreamDBOptions<TDef extends StreamStateDefinition = StreamStateDefinition, TActions extends Record<string, ActionDefinition<any>> = Record<string, never>> {
   /** Options for creating the durable stream (stream is created lazily on preload) */
-  streamOptions: DurableStreamOptions;
+  streamOptions: ExtendedStreamOptions;
   /** The stream state definition */
   state: TDef;
   /** Optional factory function to create actions with db and stream context */
@@ -281,4 +303,4 @@ declare function createStateSchema<T extends Record<string, CollectionDefinition
 declare function createStreamDB<TDef extends StreamStateDefinition, TActions extends Record<string, ActionDefinition<any>> = Record<string, never>>(options: CreateStreamDBOptions<TDef, TActions>): TActions extends Record<string, never> ? StreamDB<TDef> : StreamDBWithActions<TDef, TActions>;
 
 //#endregion
-export { ActionDefinition, ActionFactory, ActionMap, ChangeEvent, ChangeHeaders, CollectionDefinition, CollectionEventHelpers, CollectionWithHelpers, ControlEvent, CreateStreamDBOptions, MaterializedState, Operation, Row, StateEvent, StateSchema, StreamDB, StreamDBMethods, StreamDBUtils, StreamDBWithActions, StreamStateDefinition, Value, createStateSchema, createStreamDB, isChangeEvent, isControlEvent };
\ No newline at end of file
+export { ActionDefinition, ActionFactory, ActionMap, ChangeEvent, ChangeHeaders, CollectionDefinition, CollectionEventHelpers, CollectionWithHelpers, ControlEvent, CreateStreamDBOptions, ExtendedStreamOptions, MaterializedState, Operation, Row, StateEvent, StateSchema, StreamDB, StreamDBMethods, StreamDBUtils, StreamDBWithActions, StreamStateDefinition, Value, createStateSchema, createStreamDB, isChangeEvent, isControlEvent };
\ No newline at end of file
diff --git a/dist/index.js b/dist/index.js
index d85d577a170bc900f4889658be74fe9bda7efea7..6572ae378f56da1323ea33a805c513ab8efb4e49 100644
--- a/dist/index.js
+++ b/dist/index.js
@@ -455,7 +455,9 @@ function createStreamDB(options) {
 		if (consumerStarted) return;
 		consumerStarted = true;
 		streamResponse = await stream.stream({
-			live: `auto`,
+			live: options.streamOptions.live ?? `auto`,
+			json: options.streamOptions.json,
+			sseResilience: options.streamOptions.sseResilience,
 			signal: abortController.signal
 		});
 		let batchCount = 0;